################################################################################
#  Licensed to the Apache Software Foundation (ASF) under one
#  or more contributor license agreements.  See the NOTICE file
#  distributed with this work for additional information
#  regarding copyright ownership.  The ASF licenses this file
#  to you under the Apache License, Version 2.0 (the
#  "License"); you may not use this file except in compliance
#  with the License.  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
# limitations under the License.
#################################################################################
import logging
import uuid
from collections import deque
from typing import Any, Dict, List

from typing_extensions import override

from flink_agents.api.event import Event, InputEvent, OutputEvent
from flink_agents.api.memoryobject import MemoryObject
from flink_agents.runtime.local_memory_object import LocalMemoryObject
from flink_agents.api.runner_context import RunnerContext
from flink_agents.api.workflow import Workflow
from flink_agents.plan.workflow_plan import WorkflowPlan
from flink_agents.runtime.workflow_runner import WorkflowRunner


logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


class LocalRunnerContext(RunnerContext):
    """Implementation of WorkflowRunnerContext for local workflow execution.

    Attributes:
    ----------
    __workflow_plan : WorkflowPlan
        Internal workflow plan for this context.
    __key : Any
        Unique identifier for the context, correspond to the key in flink KeyedStream.
    events : deque[Event]
        Queue of events to be processed in this context.
    outputs : deque[Any]
        Queue of outputs generated by workflow execution.
    """

    __workflow_plan: WorkflowPlan
    __key: Any
    events: deque[Event]
    _store: dict[str, Any]
    _short_term_memory: MemoryObject


    def __init__(self, workflow_plan: WorkflowPlan, key: Any) -> None:
        """Initialize a new context with the given workflow and key.

        Parameters
        ----------
        workflow : Workflow
            Workflow plan used for this context.
        key : Any
            Unique context identifier, which is corresponding to the key in flink
            KeyedStream.
        """
        self.__workflow_plan = workflow_plan
        self.__key = key
        self.events = deque()
        self._store = {}
        self._short_term_memory = LocalMemoryObject(self._store, LocalMemoryObject.ROOT_KEY)

    @property
    def key(self) -> Any:
        """Get the unique identifier for this context.

        Returns:
        -------
        Any
            The unique identifier for this context.
        """
        return self.__key

    @override
    def send_event(self, event: Event) -> None:
        """Send an event to the context's event queue and log it.

        Parameters
        ----------
        event : Event
            The event to be added to the queue.
        """
        logger.info("key: %s, send_event: %s", self.__key, event)
        self.events.append(event)

    def get_short_term_memory(self) -> MemoryObject:
        """Get the short-term memory object associated with this context.

        Returns
        -------
        MemoryObject
            The short-term memory object that can be used to access and modify temporary state data.
        """
        return self._short_term_memory


class LocalRunner(WorkflowRunner):
    """Workflow runner implementation for local execution, which is
    convenient for debugging.

    Attributes:
    ----------
    __workflow_plan : WorkflowPlan
        Internal workflow plan.
    __keyed_contexts : dict[Any, LocalRunnerContext]
        Dictionary of active contexts indexed by key.
    __outputs:
        Outputs generated by workflow execution.
    """

    __workflow_plan: WorkflowPlan
    __keyed_contexts: Dict[Any, LocalRunnerContext]
    __outputs: List[Dict[str, Any]]

    def __init__(self, workflow: Workflow) -> None:
        """Initialize the runner with the provided workflow.

        Parameters
        ----------
        workflow : flink_agent_api.workflow.Workflow
            The workflow class to convert and run.
        """
        self.__workflow_plan = WorkflowPlan.from_workflow(workflow)
        self.__keyed_contexts = {}
        self.__outputs = []

    @override
    def run(self, **data: Dict[str, Any]) -> Any:
        """Execute the workflow to process the given data.

        Parameters
        ----------
        **data : dict[str, Any]
            input record from upstream.

        Returns:
        -------
        key
            The key of the input that was processed.
        """
        if 'key' in data:
            key = data['key']
        elif 'k' in data:
            key = data['k']
        else:
            key = uuid.uuid4()

        if key not in self.__keyed_contexts:
            self.__keyed_contexts[key] = LocalRunnerContext(self.__workflow_plan, key)
        context = self.__keyed_contexts[key]

        if 'value' in data:
            input_event = InputEvent(input=data['value'])
        elif 'v' in data:
            input_event = InputEvent(input=data['v'])
        else:
            msg = "Input data must be dict has 'v' or 'value' field"
            raise RuntimeError(msg)

        context.send_event(input_event)

        while len(context.events) > 0:
            event = context.events.popleft()
            if isinstance(event, OutputEvent):
                self.__outputs.append({key: event.output})
                continue
            event_type = f'{event.__class__.__module__}.{event.__class__.__name__}'
            for action in self.__workflow_plan.get_actions(event_type):
                logger.info(
                    "key: %s, performing action: %s", key, action.name
                )
                action.exec(event, context)
        return key

    def get_outputs(self) -> List[Dict[str, Any]]:
        """Get the outputs generated by workflow execution.

        Returns:
        -------
        List[Dict[str, Any]]
            The workflow execution outputs.
        """
        return self.__outputs
